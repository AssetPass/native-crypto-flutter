// Copyright 2019-2023 Hugo Pointcheval
// 
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
// --
// Autogenerated from Pigeon (v9.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif



private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

enum HashAlgorithm: Int {
  case sha256 = 0
  case sha384 = 1
  case sha512 = 2
}

enum CipherAlgorithm: Int {
  case aes = 0
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NativeCryptoAPI {
  func hash(data: FlutterStandardTypedData, algorithm: HashAlgorithm) throws -> FlutterStandardTypedData?
  func hmac(data: FlutterStandardTypedData, key: FlutterStandardTypedData, algorithm: HashAlgorithm) throws -> FlutterStandardTypedData?
  func generateSecureRandom(length: Int64) throws -> FlutterStandardTypedData?
  func pbkdf2(password: FlutterStandardTypedData, salt: FlutterStandardTypedData, length: Int64, iterations: Int64, algorithm: HashAlgorithm) throws -> FlutterStandardTypedData?
  func encrypt(plainText: FlutterStandardTypedData, key: FlutterStandardTypedData, algorithm: CipherAlgorithm) throws -> FlutterStandardTypedData?
  func encryptWithIV(plainText: FlutterStandardTypedData, iv: FlutterStandardTypedData, key: FlutterStandardTypedData, algorithm: CipherAlgorithm) throws -> FlutterStandardTypedData?
  func decrypt(cipherText: FlutterStandardTypedData, key: FlutterStandardTypedData, algorithm: CipherAlgorithm) throws -> FlutterStandardTypedData?
  func encryptFile(plainTextPath: String, cipherTextPath: String, key: FlutterStandardTypedData, algorithm: CipherAlgorithm) throws -> Bool?
  func encryptFileWithIV(plainTextPath: String, cipherTextPath: String, iv: FlutterStandardTypedData, key: FlutterStandardTypedData, algorithm: CipherAlgorithm) throws -> Bool?
  func decryptFile(cipherTextPath: String, plainTextPath: String, key: FlutterStandardTypedData, algorithm: CipherAlgorithm) throws -> Bool?
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class NativeCryptoAPISetup {
  /// The codec used by NativeCryptoAPI.
  /// Sets up an instance of `NativeCryptoAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NativeCryptoAPI?) {
    let hashChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.hash", binaryMessenger: binaryMessenger)
    if let api = api {
      hashChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let dataArg = args[0] as! FlutterStandardTypedData
        let algorithmArg = HashAlgorithm(rawValue: args[1] as! Int)!
        do {
          let result = try api.hash(data: dataArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hashChannel.setMessageHandler(nil)
    }
    let hmacChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.hmac", binaryMessenger: binaryMessenger)
    if let api = api {
      hmacChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let dataArg = args[0] as! FlutterStandardTypedData
        let keyArg = args[1] as! FlutterStandardTypedData
        let algorithmArg = HashAlgorithm(rawValue: args[2] as! Int)!
        do {
          let result = try api.hmac(data: dataArg, key: keyArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hmacChannel.setMessageHandler(nil)
    }
    let generateSecureRandomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.generateSecureRandom", binaryMessenger: binaryMessenger)
    if let api = api {
      generateSecureRandomChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let lengthArg = (args[0] is Int) ? Int64(args[0] as! Int) : args[0] as! Int64
        do {
          let result = try api.generateSecureRandom(length: lengthArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      generateSecureRandomChannel.setMessageHandler(nil)
    }
    let pbkdf2Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.pbkdf2", binaryMessenger: binaryMessenger)
    if let api = api {
      pbkdf2Channel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let passwordArg = args[0] as! FlutterStandardTypedData
        let saltArg = args[1] as! FlutterStandardTypedData
        let lengthArg = (args[2] is Int) ? Int64(args[2] as! Int) : args[2] as! Int64
        let iterationsArg = (args[3] is Int) ? Int64(args[3] as! Int) : args[3] as! Int64
        let algorithmArg = HashAlgorithm(rawValue: args[4] as! Int)!
        do {
          let result = try api.pbkdf2(password: passwordArg, salt: saltArg, length: lengthArg, iterations: iterationsArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pbkdf2Channel.setMessageHandler(nil)
    }
    let encryptChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.encrypt", binaryMessenger: binaryMessenger)
    if let api = api {
      encryptChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let plainTextArg = args[0] as! FlutterStandardTypedData
        let keyArg = args[1] as! FlutterStandardTypedData
        let algorithmArg = CipherAlgorithm(rawValue: args[2] as! Int)!
        do {
          let result = try api.encrypt(plainText: plainTextArg, key: keyArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      encryptChannel.setMessageHandler(nil)
    }
    let encryptWithIVChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.encryptWithIV", binaryMessenger: binaryMessenger)
    if let api = api {
      encryptWithIVChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let plainTextArg = args[0] as! FlutterStandardTypedData
        let ivArg = args[1] as! FlutterStandardTypedData
        let keyArg = args[2] as! FlutterStandardTypedData
        let algorithmArg = CipherAlgorithm(rawValue: args[3] as! Int)!
        do {
          let result = try api.encryptWithIV(plainText: plainTextArg, iv: ivArg, key: keyArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      encryptWithIVChannel.setMessageHandler(nil)
    }
    let decryptChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.decrypt", binaryMessenger: binaryMessenger)
    if let api = api {
      decryptChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let cipherTextArg = args[0] as! FlutterStandardTypedData
        let keyArg = args[1] as! FlutterStandardTypedData
        let algorithmArg = CipherAlgorithm(rawValue: args[2] as! Int)!
        do {
          let result = try api.decrypt(cipherText: cipherTextArg, key: keyArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      decryptChannel.setMessageHandler(nil)
    }
    let encryptFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.encryptFile", binaryMessenger: binaryMessenger)
    if let api = api {
      encryptFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let plainTextPathArg = args[0] as! String
        let cipherTextPathArg = args[1] as! String
        let keyArg = args[2] as! FlutterStandardTypedData
        let algorithmArg = CipherAlgorithm(rawValue: args[3] as! Int)!
        do {
          let result = try api.encryptFile(plainTextPath: plainTextPathArg, cipherTextPath: cipherTextPathArg, key: keyArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      encryptFileChannel.setMessageHandler(nil)
    }
    let encryptFileWithIVChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.encryptFileWithIV", binaryMessenger: binaryMessenger)
    if let api = api {
      encryptFileWithIVChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let plainTextPathArg = args[0] as! String
        let cipherTextPathArg = args[1] as! String
        let ivArg = args[2] as! FlutterStandardTypedData
        let keyArg = args[3] as! FlutterStandardTypedData
        let algorithmArg = CipherAlgorithm(rawValue: args[4] as! Int)!
        do {
          let result = try api.encryptFileWithIV(plainTextPath: plainTextPathArg, cipherTextPath: cipherTextPathArg, iv: ivArg, key: keyArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      encryptFileWithIVChannel.setMessageHandler(nil)
    }
    let decryptFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.NativeCryptoAPI.decryptFile", binaryMessenger: binaryMessenger)
    if let api = api {
      decryptFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let cipherTextPathArg = args[0] as! String
        let plainTextPathArg = args[1] as! String
        let keyArg = args[2] as! FlutterStandardTypedData
        let algorithmArg = CipherAlgorithm(rawValue: args[3] as! Int)!
        do {
          let result = try api.decryptFile(cipherTextPath: cipherTextPathArg, plainTextPath: plainTextPathArg, key: keyArg, algorithm: algorithmArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      decryptFileChannel.setMessageHandler(nil)
    }
  }
}
